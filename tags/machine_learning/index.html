<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>machine_learning - My New Hugo Site</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/tags/machine_learning/index.xml" title="My New Hugo Site">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="My New Hugo Site" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">My New Hugo Site</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">machine_learning</h1>
	</header><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-15/" rel="bookmark">
			PCA의 이해
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCA(Principal Component Analysis)의 이해   고차원의 원본 데이터를 저차원의 부분 공간으로 투영하여 데이터를 축소하는 기법
  예를 들어 10차원의 데이터를 2차원의 부분 공간으로 투영하여 데이터를 축소
  PCA는 원본 데이터가 가지는 데이터 변동성을 가장 중요한 정보로 간주하며 이 변동성에 기반한 원본 데이터 투영으로 차원 축소를 수행
  PCA는 원본 데이터 변동성이 가장 큰 방향으로 순차적으로 축들을 생성하고, 이렇게 생선된 축으로 데이터를 투영하는 방식이다.
PCA는 제일 먼저 원본 데이터에 가장 큰 데이터 변동성(Variance)을 기반으로 첫 번째 벡터 축을 생성하고, 두 번째 축은 첫번째 축을 제외하고 그 다음으로 변동성이 큰 축을 설정하는데 이는 첫번째 축에 직각이 되는 벡터(직교 벡터) 축 입니다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-14/" rel="bookmark">
			차원 축소
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		차원 축소 차원의 저주 차원의 저주 커질수록 데이터 포인트들 간 거리가 크게 늘어남, 데이터가 희소화(Sparse) 됨
수백~수천개 이상의 피처로 구성도니 포인트들간 거리에 기반한 ml 알고리즘이 무력화됨
또한 피처가 많을 경우 개별 피처간에 상관관계가 높아 선형 회귀와 같은 모델에서는 다중 공선성 문제로 모델의 예측 성능이 저하 될 가능성이 높음
수십 ~ 수백개의 피처들을 작은 수의 피처들로 축소한다면?  학습 데이터 크기를 줄여서 학습 시간 절약 불필요한 피처들을 줄여서 모델 성능 향상에 기여(주로 이미지 관련 데이터) 다차원의 데이터를 3차우너 이하의 차원 축소를 통해서 시각적으로 보다 쉽게 데이터 패턴 인지  피처 선택과 피처 추출 일반적으로 차춴축소는 피처 선택과 피처 추출로 나눌 수 있다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-13/" rel="bookmark">
			베이지안 최적화 기법 이론 보충
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		베이지안 최적화 기법 이론 보충 머신러닝 혹은 딥러닝 모델들을 학습 시킬 때 하이퍼 파라미터를 결정해야 하는 경우가 많이 있다. 이때 일반적인 하이퍼파리미터 튜닝 방법은 일저한 간격을 정해서 하이퍼파라미터 후보군을 설정하는 Grid Search와 일정 구간 내에서 랜덤하게 하이퍼 파리미터 후보군을 결정하는 Random Search가 활용된다. 하지만 두 방법론 모두 후보군에 대해서 성능을 확인한 후 비교해야 하므로 비효율적이다. 이러한 경우에 사용할 수 있는 것이 Bayesian Optimization이다. 베이지안 최적화는 크게 두 가지 핵심 모듈이 존재한다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-12/" rel="bookmark">
			Blending 기법
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		예측값을 변수로 활용하는 앙상블 테크닉 Blending Blending 은 Ensemble 의 한 종류입니다. Ensemble 이란 예측 모형을 통합해서 하나의 예측을 수행하는 것을 말합니다. Ensemble 의 묘미는 서로 다른 예측 모형들을 합쳐 더 강한 예측 모형을 만들 수 있다는 것입니다. 가령 정확도 0.7, 0.7 인 모델 두 개를 합쳐서 0.9 을 만들 수 있습니다.
Blending 의 프로세스 1. Traning/Validation/Test set 을 나눈다. 2. Training set 에 모델 피팅을 한다. 3. Validation/Test set 에 대해 예측을 한다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-11/" rel="bookmark">
			pseudo labeling
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pseudo Labeling   Pseudo Labeling이란? Labeled Data처럼 일일히 label을 하기보다, 이미 가지고 있는 Labeled data에 기반하여 대략적인 Labled을 주는 것
  Pseudo Labeling의 순서
  Labeled Data로 Model을 먼저 학습시킨다.
  그렇게 학습된 모델을 사용하여, Unlabeled Data를 예측하고 그 결과를 Label로 사용하는 Pseudo-labeled data를 만든다.
  Pseudo-labeled data와 Labeled를 모두 사용하여 다시 그 모델을 학습시킨다.
    Pseudo Labeled data  Pseudo Label은 아래와 같은 식으로, 각각의 sample에 대해, 예측된 확률이 가장 높은 것으로 정합니다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-10/" rel="bookmark">
			기본 스태킹 및 교차 검증 스태킹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Basic Stacking Model - Diagram 기반 모델들이 예측한 값들을 Stacking 형태로 만들어서 메타 모델이 이를 학습하고 예측하는 모델
교차 검증 세트 기반의 스태킹 교차 검증 세트 기반의 스태킹은 이에 대한 개선을 위해 개별 모델들이 각각 교차 검증으로 메타 모델을 위한 학습용 스태킹 데이터 생성과 예측을 위한 테스트용 스태킹 데이터를 생성한 뒤 이를 기반으로 메타 모델이 학습과 예측을 수행합니다. 이는 다음과 같이 2단계의 스텝으로 구분될 수 있습니다.    스텝 1 : 각 모델별로 원본 학습/테스트 데이터를 예측한 결과 값을 기반으로 메타 모델을 위한/학습용 테스트용 데이터를 생성합니다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-9/" rel="bookmark">
			Bayesian Optimization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		만약 우리에게 모델이 있는데, 미지의 함수(black-box function)라 예측은 잘 되는데 그 속을 들여다 볼 수 없다. 즉, f(x)가 closed-form으로 표현되지 않는다.(닫힌 형태(closed form)란 방정식(equation)의 해(solution)를 해석적(analytic)으로 표현할 수 있는 종류의 문제를 말한다.) 또 non-linear(비선형) + non-convex 해서 gradient도 찾을 수 없다.  Non-Convex한 함수란, 볼록함수와는 달리 극점이 굉장히 많을 수 있는 함수이기 때문에, Gradient Descent를 통해 구한 최솟값이 Local Minumum일 뿐, Global Minimum값은 아닐 수 있는 가능성이 생긴다. 심지어 query를 입력으로 주고 evaluate 할 때 엄청난 시간/비용이 든다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-8/" rel="bookmark">
			머신러닝 회귀 모델의 평가지표
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		회귀 평가 지표 회귀 평가를 위한 지표는 실제 값과 예측값의 차이를 기반으로 함
회귀 평가지표 MAE, MSE, RMSE, RMSLE는 값이 작을수록 회귀 성능이 좋은 것 값이 작을수록 예측값과 실제값의 차이가 없다는 것을 의미
MSE(Mean Squared Error) 실제 값과 예측 값의 차이를 제곱해 평균한 것
장점  지표 자체가 직관적이고 단순하다.  단점 스케일에 의존적이다. 예를 들어 테슬라의 주가가 900000원이고 현대자동차의 주가가 250000일 때, 두 주가를 예측하는 각각의 모델의 MSE가 똑같이 4000이 나올 경우, 분명 동일한 에러율이 아님에도 불구하고 동일하게 보여진다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-7/" rel="bookmark">
			logloss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Log Loss란?  모델 성능 평가 시 사용가능한 지표 분류 모델 평가 시 사용 확률값을 기준으로 평가  예를 들어 오지선다 객관식 문제를 국진학생과 성진학생이 풀고 있다고 가정한다. 국진 학생은 구구단을 열심히 외운 학생입니다 그래서 문제를 보자마자 99%확률로 정답은 1번 15이다라고 판단하고 1번을 고릅니다. 반면 성진학생은 아직 구구단을 다외우지 못했습니다 그래서 20% 확률로 정답을 찍기로 결심합니다 그런데 얼떨결에 1번을 찍게 되어서 문제를 맞추게 되었습니다. 단순히 정답을 맞추는 여부로 두 학생을 평가하게 된다면 두 학생은 문제를 맞추었으므로 국진 학생과 성진학생이 실력이 같다고 평가 받게 됩니다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-6/" rel="bookmark">
			GAN 이론
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GAN이란? GAN은 &lsquo;생성적 적대 신경망&rsquo;의 약자로 풀어서 쓰면, 생성자와 식별자가 서로 경쟁(Adversarial)하며 데이터를 생성(Generative)하는 모델(Network)을 뜻한다.
잡음의 이미지로부터 무엇인가를 생성해낸 결과에 대해서 분류기라고 하는 Dis가 G(Z)를 가짜라고 분류함 반면에 원래의 이미지를 받아왔을 때 원래 이미지에 대해서는 Positive하게 반응함 원래 이미지에 대해서는 확률 높게 판단해주고 가짜 이미지에 대해서는 확신도를 아주 낮게 준다.   잡음 이미지 Z 생성신경망 통과 Generator 생성 이미지 획득 G(Z) 원 이미지 X 분류기 통과 Discriminator(원래 이미지와 생성기로부터 만들어진 이미지를 동시에 입력받음) 두 분류 결과 (1:생성이미지 D(G(Z)), 2:원래이미지 D(X)) 1번에 대해서는 가짜, 2번에 대해서는 진짜로 분류하게끔 학습 목표를 제공해주어야 하는 것이 알고리즘의 총흐름도 이전 6단계 결과에 대한 적대적 학습시행 -&gt; 생성이미지 출신 저하(생성이미지가 가짜다) &amp; 원래이미지 출신 상승(원래이미지에 대한 확률을 높게 평가한다)  Gradient descending 경사하강법을 이용하면 어떤 지점으로 수렴하게 되는 결과를 받아들임 이 함수의 곡선을 가지고 Gradient ascending을 한다고 가정하면 바깥 영역에서 함수들이 굉장히 커지게 되며 그 끝을 알 수 없기 때문에 학습이 엉망으로 진행된다.
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/2</span>
	<a class="pagination__item pagination__item--next btn" href="/tags/machine_learning/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 My New Hugo Site.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>