<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.83.1" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>My New Hugo Site</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="My New Hugo Site">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="My New Hugo Site" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">My New Hugo Site</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-8/" rel="bookmark">
			머신러닝 회귀 모델의 평가지표
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		회귀 평가 지표 회귀 평가를 위한 지표는 실제 값과 예측값의 차이를 기반으로 함
회귀 평가지표 MAE, MSE, RMSE, RMSLE는 값이 작을수록 회귀 성능이 좋은 것 값이 작을수록 예측값과 실제값의 차이가 없다는 것을 의미
MSE(Mean Squared Error) 실제 값과 예측 값의 차이를 제곱해 평균한 것
장점  지표 자체가 직관적이고 단순하다.  단점 스케일에 의존적이다. 예를 들어 테슬라의 주가가 900000원이고 현대자동차의 주가가 250000일 때, 두 주가를 예측하는 각각의 모델의 MSE가 똑같이 4000이 나올 경우, 분명 동일한 에러율이 아님에도 불구하고 동일하게 보여진다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/pandas-factorize/" rel="bookmark">
			pandas.factorize()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas.factorize() 대부분의 머신러닝 알고리즘은 숫자형을 다루므로 카테고리를 텍스트에서 숫자로 바꿔줘야 한다. 이를 위해 각 카테고리를 다른 정숫값으로 매핑해주는 factorize() 함수를 사용합니다.
pandas.factorize() and Series.factorize() Parameters: values : 1D sequence. sort : [bool, Default is False] Sort uniques and shuffle labels. na_sentinel : [ int, default -1] Missing Values to mark ‘not found’. Return: Numeric representation of array  factorize() 방법의 작동 설명 import numpy as np import pandas as pd from pandas.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-7/" rel="bookmark">
			logloss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Log Loss란?  모델 성능 평가 시 사용가능한 지표 분류 모델 평가 시 사용 확률값을 기준으로 평가  예를 들어 오지선다 객관식 문제를 국진학생과 성진학생이 풀고 있다고 가정한다. 국진 학생은 구구단을 열심히 외운 학생입니다 그래서 문제를 보자마자 99%확률로 정답은 1번 15이다라고 판단하고 1번을 고릅니다. 반면 성진학생은 아직 구구단을 다외우지 못했습니다 그래서 20% 확률로 정답을 찍기로 결심합니다 그런데 얼떨결에 1번을 찍게 되어서 문제를 맞추게 되었습니다. 단순히 정답을 맞추는 여부로 두 학생을 평가하게 된다면 두 학생은 문제를 맞추었으므로 국진 학생과 성진학생이 실력이 같다고 평가 받게 됩니다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/feature-engineering/" rel="bookmark">
			Feature Engineering
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		머신러닝 모델 성능 최적화   Feature Engineering
 알고리즘이 보다 효율적으로 예측할 수 있도록 데이터 가공 기존 feature들을 다양한 형태로 재가공    알고리즘 선택
 선형, SVM, 확률, 트리 기반의 다양한 알고리즘 Boosting 계열 알고리즘의 강세 모델 혼합(Blending)m stacking    Hyper parameter 튜닝
 Feature engineering 된 데이터 세트로 최적화된 알고리즘 하이퍼 파라미터 튜닝    Feature Engineering의 주요 기법 [기본 Feature Engineering]   스케일링(Scaling)
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/pandas_join_01/" rel="bookmark">
			join 함수
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JOIN 함수 Key Value를 기준으로 데이터 프레임을 병합하는 함수
import pandas as pd d1 = {&#39;Asset_Allocation&#39;:[1,2,3,4,5,6], &#39;stock&#39;:[&#39;IDEXX&#39;,&#39;Zoetis&#39;,&#39;Freshpet&#39;,&#39;Chewy&#39;,&#39;Trupanion&#39;,&#39;WOOF&#39;] } df1 = pd.DataFrame(d1) d2 = {&#39;Asset_Allocation&#39;:[2,3,6,8], &#39;Analyze&#39;:[&#39;Buy&#39;,&#39;Hold&#39;,&#39;Sell&#39;, &#39;None&#39;]} df2 = pd.DataFrame(d2) df1 .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  df2 .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }  Inner 조인 수행. inner_join_result = pd.merge(df1, df2, on=&#39;Asset_Allocation&#39;, how=&#39;inner&#39;) inner_join_result .
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/matplotlib_study/" rel="bookmark">
			matplotlib 그래프 그리기
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import matplotlib.pyplot as plt from matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter) import seaborn as sns import numpy as np # 그냥 그림을 그릴 때 zorder의 값을 지정해주면 그 값이 레이어의 위치라고 보면 된다. # 가장 바깥 쪽에 그려지는 그림일수록 zorder의 값이 커야 한다. # zorder는 레이어의 위치 def plot_example(ax, zorder=0): ax.bar(tips_day[&#34;day&#34;], tips_day[&#34;tip&#34;], color=&#34;lightgray&#34;, zorder=zorder) ax.set_title(&#34;tip (mean)&#34;, fontsize=16, pad=12) # Values h_pad = 0.1 for i in range(4): fontweight = &#34;normal&#34; color = &#34;k&#34; if i == 3: fontweight = &#34;bold&#34; color = &#34;darkred&#34; ax.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/python-4/" rel="bookmark">
			tuple과 list의 차이
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		리스트(list)와 튜플(tuple)의 차이는 무엇인가? 공통점 1.리스트와 튜플은 둘 다 컨테이너로 일련의 객체를 저장하는데 사용한다. 둘 다 타입과 상관 없이 일련의 요소(element)를 갖을 수 있다. 두 타입 모두 요소의 순서를 관리한다. (세트(set)나 딕셔너리(dict)와 다르게 말이다.) 2.list와 tuple 모두 인덱스를 통해 특정 요소에 접근할 수 있다. 3.list와 tuple 모두 iterable하다. 즉, for문을 넣고 돌릴 수 있다. 차이점 리스트와 튜플의 기술적 차이점은 불변성에 있다. 리스트는 가변적(mutable, 변경 가능)이며 튜플은 불변적(immutable, 변경 불가)이다. 이 특징이 파이썬 언어에서 둘을 구분하는 유일한 차이점이다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/sklearn-1/" rel="bookmark">
			StandardScaler()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		사이킷런 데이터 전처리 함수 StandardScaler() 데이터의 피처 각각이 평균이 0, 분산이 1인 가우시안 정규분포를 가진 값으로 변환하는 작업을 표준화라고 한다. 기계학습 시에 SVM, 선형 회귀, 로지스틱 회귀는 가우시안 분포를 가정하고 구현되었으므로 전처리 단계에서 표준화를 해주는 것이 성능 향상에 도움이 된다. 원래 값에서 피처의 평균을 뺀 값을 피처의 표준편차로 나눠서 표준화한다. 수식으로 나타내면 다음과 같다.  사이킷런의 StandardScaler를 사용해 표준화를 진행 할 수 있다. 데이터 인코딩에서와 마찬가지로 피처 스케일링에서도 fit()과 transform()을 사용한다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-6/" rel="bookmark">
			GAN 이론
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GAN이란? GAN은 &lsquo;생성적 적대 신경망&rsquo;의 약자로 풀어서 쓰면, 생성자와 식별자가 서로 경쟁(Adversarial)하며 데이터를 생성(Generative)하는 모델(Network)을 뜻한다.
잡음의 이미지로부터 무엇인가를 생성해낸 결과에 대해서 분류기라고 하는 Dis가 G(Z)를 가짜라고 분류함 반면에 원래의 이미지를 받아왔을 때 원래 이미지에 대해서는 Positive하게 반응함 원래 이미지에 대해서는 확률 높게 판단해주고 가짜 이미지에 대해서는 확신도를 아주 낮게 준다.   잡음 이미지 Z 생성신경망 통과 Generator 생성 이미지 획득 G(Z) 원 이미지 X 분류기 통과 Discriminator(원래 이미지와 생성기로부터 만들어진 이미지를 동시에 입력받음) 두 분류 결과 (1:생성이미지 D(G(Z)), 2:원래이미지 D(X)) 1번에 대해서는 가짜, 2번에 대해서는 진짜로 분류하게끔 학습 목표를 제공해주어야 하는 것이 알고리즘의 총흐름도 이전 6단계 결과에 대한 적대적 학습시행 -&gt; 생성이미지 출신 저하(생성이미지가 가짜다) &amp; 원래이미지 출신 상승(원래이미지에 대한 확률을 높게 평가한다)  Gradient descending 경사하강법을 이용하면 어떤 지점으로 수렴하게 되는 결과를 받아들임 이 함수의 곡선을 가지고 Gradient ascending을 한다고 가정하면 바깥 영역에서 함수들이 굉장히 커지게 되며 그 끝을 알 수 없기 때문에 학습이 엉망으로 진행된다.
	</div>
</article><article class="list__item post">
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/post/machine-learning-5/" rel="bookmark">
			데이터 전처리
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		데이터 전처리   데이터 클렌징
  결손값 처리(Null/NaN 처리)
  데이터 인코딩(레이블, 원-핫 인코딩)
  머신러닝 알고리즘은 문자열 데이터 속성을 입력 받지 않으며 모든 데이터는 숫자형으로 표현되어야 합니다. 문자형 카테고리형 속성은 모두 숫자값으로 변환/인코딩 되어야 합니다.
레이블(Label) 인코딩  [TV, 냉장고, 전자레인지, 컴퓨터, 선풍기, 믹서] -&gt; [0, 1, 4, 5, 3, 2] 문제점 : 분류를 레이블 인코딩하면 관계성이 확보되지 않는다.  원-핫(One-Hot) 인코딩 원-핫 인코딩은 피처 값의 유형에 따라 새로운 피처를 추가해 고유 값에 해당하는 컬럼에만 1을 표시하고 나머지 컬럼에는 0을 표시하는 방식입니다.
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/5</span>
	<a class="pagination__item pagination__item--next btn" href="/page/4/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 My New Hugo Site.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>