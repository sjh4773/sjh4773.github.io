<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>verilog HDL 기본문법 - My New Hugo Site</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="verilog HDL 기본문법" />
<meta property="og:description" content="Inverter
  assign 구문 사용
 대부분의 경우 assign을 사용 &ldquo;조건 ? 참일경우 : 거짓일경우&rdquo; 의 문장을 자주 사용    always 구문 사용 always @ (sensitivity_list) begin &hellip; end
  always : 언제나, @ : (sensitivity_list) 신호가 변할 때
  논리가 복잡한 경우에 사용
  이 경우 if, else if, else 구문 또는 case 구문을 주로 사용
  @(sensitivity_list) : 감지신호 목록" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://sjh4773.github.io/post/vhdl1/" /><meta property="article:section" content="post" />




		<meta itemprop="name" content="verilog HDL 기본문법">
<meta itemprop="description" content="Inverter
  assign 구문 사용
 대부분의 경우 assign을 사용 &ldquo;조건 ? 참일경우 : 거짓일경우&rdquo; 의 문장을 자주 사용    always 구문 사용 always @ (sensitivity_list) begin &hellip; end
  always : 언제나, @ : (sensitivity_list) 신호가 변할 때
  논리가 복잡한 경우에 사용
  이 경우 if, else if, else 구문 또는 case 구문을 주로 사용
  @(sensitivity_list) : 감지신호 목록">

<meta itemprop="wordCount" content="868">
<meta itemprop="keywords" content="verilog_HDL," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="verilog HDL 기본문법"/>
<meta name="twitter:description" content="Inverter
  assign 구문 사용
 대부분의 경우 assign을 사용 &ldquo;조건 ? 참일경우 : 거짓일경우&rdquo; 의 문장을 자주 사용    always 구문 사용 always @ (sensitivity_list) begin &hellip; end
  always : 언제나, @ : (sensitivity_list) 신호가 변할 때
  논리가 복잡한 경우에 사용
  이 경우 if, else if, else 구문 또는 case 구문을 주로 사용
  @(sensitivity_list) : 감지신호 목록"/>

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="My New Hugo Site" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">My New Hugo Site</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">verilog HDL 기본문법</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">JiHun</span>
</div></div>
		</header><div class="content post__content clearfix">
			<ul>
<li>
<p>Inverter</p>
</li>
<li>
<p>assign 구문 사용</p>
<ul>
<li>대부분의 경우 assign을 사용</li>
<li>&ldquo;조건 ? 참일경우 : 거짓일경우&rdquo; 의 문장을 자주 사용</li>
</ul>
</li>
<li>
<p>always 구문 사용
always @ (sensitivity_list) begin
&hellip;
end</p>
</li>
<li>
<p>always : 언제나, @ : (sensitivity_list) 신호가 변할 때</p>
</li>
<li>
<p>논리가 복잡한 경우에 사용</p>
</li>
<li>
<p>이 경우 if, else if, else 구문 또는 case 구문을 주로 사용</p>
</li>
<li>
<p>@(sensitivity_list) : 감지신호 목록</p>
<ul>
<li>sensitivity_list에 나열된 신호들 중 하나라도 값이 바뀌면 내부 문장이 실행</li>
<li>sensitivity_list에는 출력에 영향을 주는 모든 신호가 나열되어야 함</li>
</ul>
</li>
<li>
<p>assign 구문을 사용한 작성</p>
<pre><code>  wire out;
  assign out = ~in;

  wire out;
  assign out = (in == 0)

  wire out;
  assign out = ~(in == 1)

  wire out;
  assign out = in ? 0 : 1;

  wire out;
  assign out = ~in ? 1 : 0;
</code></pre>
</li>
<li>
<p>always 구문을 사용한 작성</p>
<pre><code>  reg out;
  always @(in)
  out = ~in;

  reg out;
  always @(in) begin
  if (in) out = 0;
  else out = 1;
  end

  reg out;
  always @(in) begin
  case (in)
      0 : out = 1;
      1 : out = 0;
      default : out = 1'bx;
  endcase
  end
</code></pre>
</li>
<li>
<p>인버터 모듈</p>
<ul>
<li>
<p>2개의 입출력 포트(port)</p>
</li>
<li>
<p>입력신호는 in, 출력 신호는 out</p>
<pre><code>module inverter (in, out);
input in;
output out;

wire out;
assign out = ~in;
endmodule
</code></pre>
</li>
</ul>
</li>
<li>
<p>OR gate(3-input OR gate)</p>
<pre><code>  wire out;
  assign out = in[2] | in[1] | in[0];

  wire out;
  assign out = |in[2:0];

  wire out;
  assign out = (in[2:0] != 3`b000);

  wire out;
  assign out = ~(in[2:0] == 3`b000);
</code></pre>
</li>
<li>
<p>NOR gate</p>
<pre><code>  wire out;
  assign out = ~(in[2] | in[1] | in[0]);

  wire out;
  assign out = ~|in[2:0];

  wire out;
  assign out = ~(in[2:0] != 3`b000);

  wire out;
  assign out = in[2:0] == 3`b000;
</code></pre>
</li>
<li>
<p>반가산기</p>
<ul>
<li>
<p>2개의 입력을 받아 덧셈을 수행하고 sum과 carry를 발생</p>
<pre><code>module half_adder (a, b, sum, cout);
input a, b;
output sum, cout;
wire sum, cout;

assign sum = a ^ b;
assign cout = a &amp; b;
endmodule
</code></pre>
</li>
</ul>
</li>
<li>
<p>전가산기</p>
<ul>
<li>
<p>3개의 입력을 받아 sum과 carry를 발생</p>
</li>
<li>
<p>반가산기 2개와 or 게이트를 사용</p>
<pre><code>module full_adder (a, b, cin, sum, cout);
input a, b, cin;
output sum, cout;
wire sum, cout;

assign sum = (a ^ b) ^ cin;
assign cout = ((a ^ b) &amp; cin) | (a &amp; b);
endmodule
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Multiplexer(mux)</p>
<ul>
<li>
<p>여러 개의 입력 중 하나만을 선택하여 출력</p>
<ul>
<li>sel == 1 이면 out = a</li>
<li>sel == 0 이면 out = b</li>
</ul>
</li>
<li>
<p>assign을 사용</p>
<pre><code>  wire out;
  assign out = (sel == 1) ? a : b;

  wire out;
  assign out = sel ? a : b;
</code></pre>
</li>
<li>
<p>always를 사용</p>
<pre><code>  reg out;
  always @(sel or a or b)
  out = sel &gt; a : b;

  reg out;
  always @(sel or a or b) begin
  if (sel) out = a;
  else out = b;
  end

  module mux2to1 (a, b, sel, out);
  input a, b, sel;
  output out;
  reg out;
  always @(sel or a or b) begin
      case (sel)
      1`b1 : out = a;
      1`b0 : out = b;
      endcase
  end
  endmodule
</code></pre>
</li>
</ul>
<p>-multi-bit mux</p>
<pre><code>    wire [3:0] out;
    assign out[3:0] = sel ? a[3:0] : b[3:0];

    module mux4bit (a, b, sel, out);
    input [3:0] a, b;
    input sel;
    output [3:0] out;

    reg [3:0] out;
    always @(sel or a or b) begin
        case(sel)
        1'b1 : out = a; // a, b, out 이 모두 4비트로
        1'b0 : out = b; // 선언되어 있으므로 비트표시 생략, out[3:0] = a[3:0]
        endcase
    end
    endmodule
</code></pre>
<ul>
<li>
<p>가산기(adder)</p>
<ul>
<li>
<p>가산기 작성시 &lsquo;+&rsquo; 연산자 사용</p>
</li>
<li>
<p>합성시에 자동으로 속도에 맞는 가산기가 발생됨</p>
</li>
<li>
<p>4비트 + 4비트 carry와  4비트의 sum</p>
<pre><code>wire carry_out;
wire [3:0] sum;
assign { carry_out, sum[3:0] } = a[3:0] + b[3:0];
</code></pre>
</li>
</ul>
</li>
<li>
<p>가감산기(adder and subtractor)</p>
<ul>
<li>
<p>add_nsub == 1 : 가산</p>
</li>
<li>
<p>add_nsub == 0 : 감산</p>
<pre><code>wire carry_out;
wire [3:0] sum;
assign {carry_out, sum[3:0]} = add_nsub &gt; a[3:0] + b[3:0] : a[3:0] + ~b[3:0] + 4'b1;
</code></pre>
</li>
</ul>
</li>
<li>
<p>디코더</p>
<ul>
<li>
<p>코드화된 신호를 받아 하나의 출력만을 1 또는 0으로 구동</p>
<pre><code>wire[3:0] y;

assign y[0] = !a[1] &amp; !a[0];
assign y[1] = !a[1] &amp; a[0];
assign y[2] = a[1] &amp; !a[0];
assign y[3] = a[1] &amp; a[0];

wire[3:0] y;

assign y[0] = a[1:0] == 2'b00;
assign y[1] = a[1:0] == 2'b01;
assign y[2] = a[1:0] == 2'b10;
assign y[3] = a[1:0] == 2'b11;

wire[3:0] y;

assign y = (a == 2'b00) ? 4'b0001 :
            (a == 2'b01) ? 4'b0010 :
            (a == 2'b10) ? 4'b0100 :
                                4'b1000;

reg[3:0] y;

always @(a) begin
case(a)
    2'b00 : y = 4'b0001;
    2'b01 : y = 4'b0010;
    2'b10 : y = 4'b0100;
    2'b11 : y = 4'b1000;
endcase
end
</code></pre>
</li>
</ul>
</li>
<li>
<p>인코더</p>
<ul>
<li>
<p>디코더와 반대의 동작으로 개별 신호를 묶어 코드화</p>
<pre><code>wire b, a, v
assign b = d3 || (!d3 &amp; d2);
assign a = d3 || (!d3 &amp; !d2 &amp; d1);
assign v = !(!d3 &amp; !d2 &amp; !d1 &amp; !d0);
</code></pre>
</li>
</ul>
</li>
<li>
<p>ROM</p>
<ul>
<li>ROM은 메모리로 분류되지만, 동작관점에서는 조합논리회로임.</li>
</ul>
</li>
<li>
<p>DFF</p>
<pre><code>  module d_ff (clk, d, q);
  input clk;
  input d;
  output q;

  reg q;
  always @(posedge clk)
      q &lt;= d;

  endmodule
</code></pre>
</li>
<li>
<p>DFF with asychronous reset</p>
<pre><code>  reg q;
  always @(posedge clk or negedge rst) begin
  if (!rst) q &lt;= 0;
  else q &lt;= d;
  end
</code></pre>
</li>
<li>
<p>DFF with enable</p>
<pre><code>  reg q;
  always @(posedge clk or negedge rst) begin
  if(!rst) q &lt;= 0;
  else if (en) q &lt;= d;
  else q &lt;= q; // needless
  end
</code></pre>
</li>
<li>
<p>DFF with q and qbar outputs</p>
<pre><code>  reg q, q_bar;
  always @(posedge clk) begin
  q &lt;= d;
  q_bar &lt;= ~d;
  end

  reg q;
  wire q_bar;

  always @(posedge clk)
  q &lt;= d;
  assign q_bar = ~q;
</code></pre>
</li>
</ul>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/verilog_hdl/" rel="tag">verilog_HDL</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<div class="authorbox__header">
		<span class="authorbox__name">About JiHun</span>
	</div>
	<div class="authorbox__description">
		John Doe&rsquo;s true identity is unknown. Maybe he is a successful blogger or writer. Nobody knows it.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/post/blackfriday/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">정형 데이터마이닝 blackfriday</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/post/ai/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">파이토치로 만드는 신경망</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2021 JiHun.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>